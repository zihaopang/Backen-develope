# 第七题：整数反转
这一题和判断回文数差不多，不过需要判断溢出的情况
核心代码是这样：
```
while(x != 0)
{
	int pop = x%10;
    sum = sum*10+pop;
}
```
但是`sum = sum*10+pop;`容易溢出，此时的方法是预防sum*10+pop的溢出情况，
```
//在sum = sum*10+pop之前添加判断
if((sum > Integer.MAX_VALUE) || (sum == Integer.MAX_VALUE && pop > Integer.MAX_VALUE%10))
	return 0;
if((sum < Integer.MIN_VALUE) || (sum == Integer.MIN_VALUE && pop < Integer.MIN_VALUE%10))
	return 0;
```

# 第九题:判断回文数
```
class Solution {
    public boolean isPalindrome(int x) {
        int temp = x;
        int sum = 0;
        if(x < 0)
            return false;
        
        while(temp != 0)
        {
            sum = sum*10 + temp%10;
            temp /= 10;
        }
        if(sum == x)
            return true;
        else
            return false;
    }
}
```
# 第20题：括号匹配
基本的思想，遇到左括号压栈，右括号先看看栈是否空，非空取栈顶，看看是否和当前字符串匹配，然后计数加2.
```
class Solution {
    public boolean isValid(String s) {
        if(s == "")
            return true;
        int len = s.length();
        Stack stk = new Stack();
        int cnt = 0;
        
        for(int i = 0; i < len; i++)
        {
            char c = s.charAt(i);
            switch(c)
            {
                case '(':
                    {
                        stk.push(c);
                        break;
                    }
                case '[':
                    {
                        stk.push(c);
                        break;
                    }
                case '{':
                    {
                        stk.push(c);
                        break;
                    }
                case ')':
                    {
                        if(!stk.empty())
                        {
                            char ch = (char)stk.peek();
                            if(ch == '(')
                            {
                                stk.pop();
                                cnt += 2;
                            }
                        }
                        break;
                    }
                case ']':
                    {
                        if(!stk.empty())
                        {
                            char ch = (char)stk.peek();
                            if(ch == '[')
                            {
                                stk.pop();
                                cnt += 2;
                            }
                        }
                        break;
                    }
                case '}':
                    {
                        if(!stk.empty())
                        {
                            char ch = (char)stk.peek();
                            if(ch == '{')
                            {
                                stk.pop();
                                cnt += 2;
                            }
                        }
                        break;
                    }
            }
            
        }
        
        if(cnt == len)
            return true;
        else
            return false;
    }
}
```
# 第26题：删除排序数组中的重复项
此题思想，用k计数，就是记录不重复数据，顺便作为新数组下标。用j作为探针，不断地向前探测，前提是i+j不能大于len，如果探测到不等于nums[i]的数值，那么就跳出，记录该数值，然后在该数值重新开始
核心代码
```
        while(i < len)
        {
            nums[k++] = nums[i];
            int j = 1;
            
            while((i+j) < len)
            {
                if(nums[i] == nums[i+j])
                    j++;
                else
                    break;
            }
            
            i = j+i;
        }
```
# 第58题，最后一个单词的长度
该题的思想在于用空格分割字符串，除了空字符串以及不包含空格的情况以外，还存在着字符串首尾存在空格的情况，需要使用trim方法去除空格。解题时候的错误有
- s.lastIndexOf(' ')，该方法接收一个字符，不是字符串" "
- substring而不是subString
```
class Solution {
    public int lengthOfLastWord(String s) {
        if(s.isEmpty())
            return 0;
        
        s = s.trim();
        
        if(!s.contains(" "))
            return s.length();
        
        int last = s.lastIndexOf(' ');
        
        String res = s.substring(last+1);
        
        return res.length();
    }
}
```

# 14题：最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1:

输入: ["flower","flow","flight"]
输出: "fl"
示例 2:

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。

主要就是每次要确定一列，进行纵向扫描，如果这一列扫描的结果完全一致，就让公共前缀子序列的长度加1，如果不一致，说明公共前缀子序列结束了，要break.

![1.最长公共前缀](http://)

代码：

```
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int nums = strs.length;
        if(nums == 0)   return "";
        if(nums == 1)   return strs[0];

        int minLen = strs[0].length();
        int commonLen = 0;
        for(int i = 1; i < nums; i++)
            if(strs[i].length() < minLen)     
                minLen = strs[i].length();

        for(int i = 0; i < minLen; i++)
        {
            int j = 0;

            for(j = 0; j < nums; j++)
            {
                if(strs[j].charAt(i) == strs[0].charAt(i))
                    continue;
                else
                    break;
            }

            if(j == nums)   commonLen++;
            else    break;
        }
        if(commonLen == 0)  return "";

        return strs[0].substring(0,commonLen);
    }
}
```

注意点：

1.java数组的长度是属性，直接调用arr.length，没有括号，java字符串长度树方法，调用lenght()方法，有括号
2.substring(beginIndex,endIndex)，其中beginIndex是包含在内的，endIndex不包含在内，两个都是代表的下标


# 21. 合并两个有序链表

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

主要就是对链表的合并，要注意使用temp放置断链

题解：

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(0);//头节点
        ListNode r = new ListNode(0);//尾部节点
        ListNode temp = new ListNode(0);//temp节点放置断链
        ListNode p1 = l1;//两个扫描节点
        ListNode p2 = l2;

        head.next = null;
        r = head;

        while(p1 != null && p2 != null){
            if(p1.val <= p2.val){
                temp = p1;//用temp节点取出要插入节点
                p1 = p1.next;//扫描节点后移

                temp.next = r.next;
                r.next = temp;
                r = temp;
            }
            else{
                temp = p2;
                p2 = p2.next;

                temp.next = r.next;
                r.next = temp;
                r = temp;
            }
        }

        if(p1 != null)  r.next = p1;//list1没有扫描完成，直接接上
        else if(p2 != null) r.next = p2;////list2没有扫描完成，直接接上
        else    r.next = null;//全部扫描完毕，尾部节点添加null

        return head.next;

    }
}
```

# 28. 实现 strStr()
实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:

输入: haystack = "hello", needle = "ll"
输出: 2
示例 2:

输入: haystack = "aaaaa", needle = "bba"
输出: -1

依然是暴力解法，效果不是很理想

注意这边的判空需要isEmpty函数

```
    public int strStr(String haystack, String needle) {
        if(needle.isEmpty())
            return 0;
        if(haystack.isEmpty())
            return -1;
        
        for(int i = 0; i < haystack.length(); i++){
            int j = 0,k = 0;
            if(haystack.charAt(i) == needle.charAt(0))
            {
                for(j = 0,k = i; j < needle.length() && k < haystack.length(); j++,k++){
                    if(haystack.charAt(k) == needle.charAt(j))
                        continue;
                    else
                        break;
                }
            }

            if(j == needle.length())
                return i;
            else
                i = k;
        }

        return -1;
    }
```

# 67. 二进制求和
给定两个二进制字符串，返回他们的和（用二进制表示）。

输入为非空字符串且只包含数字 1 和 0。

示例 1:

输入: a = "11", b = "1"
输出: "100"
示例 2:

输入: a = "1010", b = "1011"
输出: "10101"

思路：这两个字符串的长度一定不同，那么先将短的那一个用0补齐，然后就可以使用进位加减了。定义一个进位符号，二进制的计算规则是：
1.0+0=0
2.0+1=1
3.1+1=10
4.1+1+1=11（其中1为进位符号）

当字符串同步遍历完成过后，如果进位符号仍然是1，那么就在结果最前面加1.当然，结果是需要逆置的。

解答：

```
class Solution {
    public String addBinary(String a, String b) {
        int index = 0;//进位标志  
        String zeros = "",result="";

        if(a.isEmpty()&&b.isEmpty())    return "0";

        if(a.isEmpty()) return b;
        if(b.isEmpty()) return a;

        if(a.length() > b.length()){
            StringBuilder sb = new StringBuilder(b);
            for(int i = 0; i < a.length()-b.length(); i++)
                zeros += "0";  
            sb.insert(0,zeros);  
            b = sb.toString();         
        }else{
            StringBuilder sb = new StringBuilder(a);
            for(int i = 0; i < b.length()-a.length(); i++)
                zeros += "0";  
            sb.insert(0,zeros);  
            a = sb.toString();             
        }

        int len = a.length()>b.length()?a.length():b.length();

        for(int i = len-1; i >= 0; i--)
        {
            if(a.charAt(i) == '0' && b.charAt(i) == '0')
            {
                if(index == 1)
                {
                    result += "1";
                    index = 0;
                }
                else
                    result += "0";
            }
            else if(a.charAt(i) == '1' && b.charAt(i) == '0')
            {
                if(index == 1)
                    result += "0";
                else
                    result += "1";
            }
            else if(a.charAt(i) == '0' && b.charAt(i) == '1')
            {
                if(index == 1)
                    result += "0";
                else
                    result += "1";
            }
            else
            {
                if(index == 1)
                    result += "1";
                else
                {
                    result += "0";
                    index = 1;
                }
            }
        }

        if(index == 1)
            return new StringBuilder(result+"1").reverse().toString();
        else
            return new StringBuilder(result).reverse().toString();
    }
}
```

注意点：
1.在字符串的固定位置插入字符串

```
StringBuilder sb = new StringBuilder(a);
sb.insert(位置LOC,插入的字符串);//插入的字符串在位置的前面
return sb.toString()
```
2.字符串反转

`return new StringBuilder(result+"1").reverse().toString();`

# 69. x 的平方根

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2
示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。

牛顿法求解平方根：

![2.x 的平方根](http://)

计算x2 = n的解，令f(x)=x2-n，相当于求解f(x)=0的解，如左图所示。

   首先取x0，如果x0不是解，做一个经过(x0,f(x0))这个点的切线，与x轴的交点为x1。

   同样的道理，如果x1不是解，做一个经过(x1,f(x1))这个点的切线，与x轴的交点为x2。

   以此类推。

   以这样的方式得到的xi会无限趋近于f(x)=0的解。

求出 X(i+1)和X(i)的关系：xi+1 = (xi + n/xi) / 2

解法：

```
class Solution {
    public int mySqrt(int x) {
        if(x == 0)  return 0;
        double res = 1.0;
        double last = 0.0;

        while(res != last)
        {
            last = res;
            res = (res+x/res)/2;
        }

        return (int) Math.floor(res);
    }
}
```

用last记录上一个res的数值，如果此次的res和上一次的相同，说明逼近成功

注意点：double向下取整：(int)Math.floor//地板，向下

# 70. 爬楼梯
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。

第 i阶可以由以下两种方法得到：
在第 (i−1) 阶后向上爬一阶。
在第 (i−2) 阶后向上爬 22 阶。

所以到达第 i阶的方法总数就是到第 (i−1) 阶和第 (i−2) 阶的方法数之和。
令 dp[i]dp[i] 表示能到达第 i 阶的方法总数：dp[i]=dp[i-1]+dp[i-2]

所以这题是一个简单的斐波拉契数列问题：

代码：

```
class Solution {
    public int climbStairs(int n) {
        if(n == 1)
            return 1;
        
        int first = 1;
        int second = 2;
        int third = 0;
        for(int i = 3; i <=n; i++){
            third = first+second;//记录第三个数
            first = second;//第一个数边第二个数
            second = third;//第二个数编程第三个数
        }

        return second;
    }
}
```

# 83. 删除排序链表中的重复元素

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:

输入: 1->1->2
输出: 1->2
示例 2:

输入: 1->1->2->3->3
输出: 1->2->3

这一题首先明确一点，java是不需要释放内存的，无需free操作，还有就是短路问题，比如：
`if(p1== null || p1.next == null)`，`p1==null`应该放在`p1.next == null`的前面，应为p1如果等于null的话，p1.next就会不复存在，`(p2 != null) && (p2.val == p1.val)`也是同理

解答：

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode p1 = head;
        
        if(p1== null || p1.next == null)
            return p1;
        
        ListNode p2 = p1.next;

        while(p1.next != null){
            while((p2 != null) && (p2.val == p1.val))
                p2 = p2.next;
            
            p1.next = p2;//架空操作
            
            if(p2 == null)
                break;
            
            p1 = p2;//p1放到p2的位置上
            p2 = p2.next;//p2向前进
        }

        return head;
    }
}
```

# 88. 合并两个有序数组
给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

说明:

初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
示例:

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]

思路：先截取nums1的有效部分，再将nums2加到nums1末尾，在排序，搞定。。。

```
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {

        int temp[] = new int[m+n];
        System.arraycopy(nums1,0,temp,0,m);

        for(int i = m,j = 0; i < (m+n) && j < n; i++,j++)
            temp[i] = nums2[j];
        
        Arrays.sort(temp);

        for(int i = 0; i < (m+n); i++)
            nums1[i] = temp[i];

    }
}
```

注意点：

1.数组拷贝函数：`System.arraycopy(源数组，源数组开始点，目标数组，目标数组开始点，拷贝长度)`
2.排序函数：`Arrays.sort(temp);`

# 100. 相同的树

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
示例 2:

输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
示例 3:

输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false

做一个递归先序遍历就行了

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null)
            return true;
        if(p == null || q == null)
            return false;
        if(p.val != q.val)
            return false;
            
        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
    }
}
```