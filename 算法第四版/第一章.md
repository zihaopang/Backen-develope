# 1.1.10 二分查找
```
	public static int rank(int key,int nums[]){
		int high = nums.length-1;
		int low = 0,mid = 0;
		
		while(low <= high){
			mid = (high + low)/2;
			if(nums[mid] > key)
				high = mid -1;
			else if(nums[mid] < key)
				low = mid+1;
			else
				break;
		}
		
		return mid;
	}
```
# 1.3 背包、对列、栈
### 背包
| 方法作用 | 函数 |
|--------|--------|
|创建一个空背包|   Bag<Item> bag = new Bag<Item>()|
|背包是否为空|boolean isEmpty()|
|背包中元素数量|int size()|

背包不支持删除元素的集合数据类型，可以使用for-each

### 队列
| 方法作用 | 函数 |
|--------|--------|
|创建空队列|Queue<Item> queue = new Queue<Item>()|
|出队|Item dequeue()|
|入队|Item enqueue()|
|判断空|boolean isEmpty()|
|元素数量|int size()|

### 栈
| 方法作用 | 函数 |
|--------|--------|
|创建空栈|Stack<Item> stk = new Stakc<Item>()|
|出栈|Item pop()|
|入栈|void push(Item item)|
|判断空|boolean isEmpty()|
|元素数量|int size()|

### 样例：算术表达式求值
1.遇到左括号忽略
2.遇到右括号从操作符栈中弹出一个操作符，从数值栈中弹出两个数，计算过后压入数值栈
3.遇到操作符压入操作符栈
4.操作数压入操作数栈

注意点
1.Stack只支持包装类型
2.Double.parseDouble()转换为double类型
3.char+""：将字符型转换为字符串
```
import java.util.*;

public class Test{

	public static void main(String args[]){
		String exp = "((1+2)*3)";
		int len = exp.length();
		
		Stack<Double> numStk = new Stack<Double>();
		Stack<Character> ops = new Stack<Character>();
		
		for(int i = 0; i < len; i++)
		{
			char ch = exp.charAt(i);

			switch(ch){
			case '(':{
				break;
			}
			case ')':{
				char op = ops.pop();
				double db = numStk.pop();
				double res = 0.0;
				if(op == '+')	res = db+numStk.pop();
				else if(op == '-')	 res = db-numStk.pop();
				else if(op == '*')	res = db*numStk.pop();
				else	res = db/numStk.pop();
				
				numStk.push(res);
				break;
			}
			case '+':
			case '-':
			case '*':
			case '/':{
				ops.push(ch);
				break;
			}
			default:{
				numStk.push(Double.parseDouble(ch+""));
				break;
			}
			}
		}
		
		System.out.println(numStk.pop());
	}
}
```
### 用数组实现可调节大小的栈
核心代码就是调整大小的函数：
```
public void resize(int newSize){
	Item[] temp = (Item[]) new Object[newSize];
    int len = this.size();
    for(int i = 0; i < len; i++)
    	temp[i] = stk[i];
    
    temp = stk;
}
```
注意点：
泛型数组的定义`Item[] temp = (Item[]) new Object[newSize];`，需要为Object然后在向下转型。
### 用数组实现可调节大小的队列
```
import java.util.*;

public class Test{
	static class QueueResize<Item>{
		@SuppressWarnings("unchecked")
		private Item[] queue = (Item[]) new Object[1];
		private int rear = -1;
		private int front = -1;
		public int getSize(){
			return rear - front;
		}
		public void enqueue(Item data){
			if(this.getSize() == queue.length)
			{
				resize(2*queue.length);
				System.out.println("smaller size");
			}
			queue[++rear] = data;
		}
		public Item dequeue(){
			if(this.getSize() == queue.length/4)
			{
				System.out.println("bigger size");
				resize(queue.length/2);
			}
			return queue[++front];
		}
		public void resize(int newSize){
			@SuppressWarnings("unchecked")
			Item[] temp = (Item[])new Object[newSize];
			for(int i = 0;i < queue.length; i++)
				temp[i] = queue[i];
			queue = temp;
		}
		
	}
	
	public static void main(String args[]){
		QueueResize<Integer> que = new QueueResize<Integer>();
		que.enqueue(1);
		que.enqueue(2);
		que.enqueue(3);
		que.enqueue(4);
	}
}
```

### 链表实现栈
```
import java.util.*;

class LinkNode<Item>{
	Item data;
	LinkNode<Item> next;
}

class LinkStack<Item>{
	private LinkNode<Item> head = new LinkNode<Item>();
	
	@SuppressWarnings("hiding")
	public <Item> LinkStack(){
		head = null;
	}
	public boolean isEmpty(){
		return head == null;
	}
	public void push(Item data){
		LinkNode<Item> newNode = new LinkNode<Item>();
		newNode.data = data;
		newNode.next = head;
		head = newNode;
	}
	public Item pop(){
		if(this.isEmpty())
			return null;
		LinkNode<Item> temp = head;
		head = head.next;
		return temp.data;
	}
	public void reverse(){
		if(isEmpty())
			return;
		LinkNode<Item> temp = head;
		
		while(temp != null){
			System.out.println(temp.data);
			temp = temp.next;
		}
	}
}

public class Test{
	
	public static void main(String args[]){
		LinkStack<Integer> lskt = new LinkStack<Integer>();
		lskt.push(1);
		lskt.push(5);
		lskt.push(4);
		lskt.push(9);
		lskt.reverse();
		System.out.println("pop "+lskt.pop());
		lskt.reverse();
	}
}
```

### 链表实现队列
```
import java.util.*;

class LinkNode<Item>{
	Item data;
	LinkNode<Item> next;
}

class LinkQueue<Item>{
	@SuppressWarnings("unused")
	private LinkNode<Item> head = new LinkNode<Item>();
	@SuppressWarnings("unused")
	private LinkNode<Item> tail = new LinkNode<Item>();
	
	@SuppressWarnings("hiding")
	public <Item>LinkQueue(){
		head.next = null;
	}
	public boolean isEmpty(){
		return head.next == null;
	}
	public Item dequeue(Item data){
		if(isEmpty())
			return null;
		
		LinkNode<Item> temp = head.next;
		
		head = head.next;
		return temp.data;
	}
	public void enqueue(Item data){
		LinkNode<Item> newNode = new LinkNode<Item>();
		newNode.data = data;
		
		LinkNode<Item> temp = head;
		

		while(temp.next != null)
			temp = temp.next;
		newNode.next = temp.next;
		temp.next = newNode;
			
	}
	public void reverse(){
		LinkNode<Item> temp = head.next;
		while(temp != null)
		{
			System.out.println(temp.data);
			temp = temp.next;
		}
	}
}

public class Test{
	public static void main(String args[]){
		LinkQueue<Integer> que = new LinkQueue<Integer>();
		que.enqueue(3);
		que.enqueue(2);
		que.enqueue(7);
		que.enqueue(4);
		que.reverse();
	}
}
```