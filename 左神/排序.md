# 冒泡排序
冒泡排序的基本思想是元素之间两两相隔比较，一趟过后最大的元素沉到底部，第二次后第二大元素沉到倒数第二个位置，一次类推，比如：
3,2,4,1,10,6,8
1.第一趟：
- 3和2比较，变成：2,3,4,1,10,6,8
- 3与4比较，不变
- 4与1比较，交换位置：2,3,1,4,10,6,8
- 4与10比较，不变
- 10与6比较，交换位置：2,3,1,4,6,10,8
- 10与8比较，交换位置：2,3,1,4,6,8,10
可见，一趟过后，最大元素沉底，N趟过后，排序完成
冒泡排序代码

```
package thread;

public class LearnThread {
    public static void main(String[] args) {
        //冒泡排序
        int num[] = new int []{10,9,8,3,5,6,1};

        for(int end = num.length-1; end > 0; end--){
            for(int j = 0; j < end; j++){//j不会越界，因为是小于end
                if(num[j] < num[j+1])
                {
                    int temp = num[j];
                    num[j] = num[j+1];
                    num[j+1] = temp;
                }
            }
        }

        for(int k : num){
            System.out.println(k);
        }
    }
}
```

测试程序,可以学习下测试的方法，叫做**对数器**

```
package thread;

import java.util.Arrays;

public class LearnThread {
	
	public static int[] bubbleSort(int[] num){
		
		if(num.length == 0)
			return null;
		if(num.length == 1)
			return num;
		
		for(int end = num.length-1; end > 0; end--){
			for(int j = 0; j < end; j++){//j不会越界，因为是小于end
				if(num[j] < num[j+1])
				{
					int temp = num[j];
					num[j] = num[j+1];
					num[j+1] = temp;
				}
			}
		}
		
		return num;
	}
	
	public static int[] generateRandomArray(int size,int value){
		/*
		 * 这一句生成一个[0,size]大小的数组，因为Math.random的范围是[0,1)，
		 * 比如size为6，size+1等于7,那么7如果乘以0.9在专成整型，就是6
		 */
		int num[] = new int[(int)((size+1)*Math.random())];
		for(int i = 0; i < num.length; i++){
			num[i] = (int)(value*Math.random()-value*Math.random());
		}
		
		return num;
	}
	
	public static int[] systemSort(int[] num){
		Arrays.sort(num);
		return num;
	}
	
	public static boolean arrayEqual(int[] num1,int[] num2){
		for(int i = 0;i < num1.length; i++){
			if(num1[i] == num2[i])
				continue;
			else
				return false;
		}
		
		return true;
	}
	
	public static void main(String[] args) {
		int nums[] = generateRandomArray(100, 100);
		int  num1[] = bubbleSort(nums);
		int num2[] = systemSort(nums);
		for(int i = 0; i < 10000; i++)
		{
			if(!arrayEqual(num1, num2)){
				System.out.println("测试错误");
			}
		}
	}
}
```

# 选择排序
选择排序就是每次在剩余的序列中选择最小的与前面的元素进行交换。

```
public static int[] bubbleSort(int[] num){

    if(num.length == 0)
        return null;
    if(num.length == 1)
        return num;

    for(int i = 0; i < num.length; i++){
        int index = 0;
        for(int j = i+1; j < num.length; j++)
        {
            int min = num[j];
            if(num[j] < min){
                min = num[j];
                index = j;
            }
        }
        int temp = num[i];
        num[i] = num[index];
        num[index] = temp;
    }

    return num;
}
```

# 插入排序
举例：6，3，2，4
- 第一步，6不动，看3，2，4，程序默认3之前的序列都是有序的
- 第二步，3和6比较，3比6小，故3与6交换，变成：3，6，2，4，现在3，6这个部分有序
- 第三步，2与6比较，2比6小，故交换，变成3，2，6，4，2再和3比较，2比3小，故交换，编程2，3，6，4
- 第四步，4比6小，故交换，4比3大，所以停止，得出最后结果：2，3，4，6

代码：

```
	public static int[] insertSort(int[] num){
		
		if(num.length == 0)
			return null;
		if(num.length == 1)
			return num;
		
		for(int i = 1; i < num.length; i++){
			
			for(int j = i;j > 0 && num[j] < num[j-1]; j--)
					swap(num,j,j-1);
		}
		
		return num;
	}
```

# 归并排序

递归举例：
```
	public static int getMax(int num[],int l,int r){
		if(l == r){
			return num[l];
		}
		int mid = (l+r)/2;
		int maxLeft = getMax(num,l,mid);
		int maxRight = getMax(num,mid+1,r);
		
		return Math.max(maxLeft, maxRight);
	}
```

归并排序分为两个步骤，一个是归，也就是分块。一个是并，也就是合并。
举例：比如5，3，4，6，7，2，9，3的这个序列
- 第一步，将其一分为二，分为5，3，4，6 | 7，2，9，3
- 第二步，再分，将其分为：5，3 | 4，6 | 7，2 | 9，3
- 第三步，再分，将其分成：5 | 3 | 4 | 6 | 7 | 2 | 9 | 3
- 第四步，合并：5和3两个子序列调用merge函数变成3，5，故为5，3 | 4 | 6 | 7 | 2 | 9 | 3
- 继续合并 4，6两个子序列调用merge函数变成4，6，故为5，3 | 4，6 | 7 | 2 | 9 | 3
- 继续合并：5，3和4，6两个子序列调用merge函数变成3，4，5，6故为3，4，5，6 | 7 | 2 | 9 | 3
- 如此递归，直至全部有序

图示：
![1.归并排序1](http://)
![2.归并排序2](http://)
其中的合并代码为：
![3.归并函数中的merge函数](http://)
### 代码

```
	public static void mergeSort(int[] num,int L,int R){
		
		if(L == R)
			return;
		int mid = L + (R-L)/2;
		mergeSort(num,L,mid);
		mergeSort(num, mid+1, R);
		merge(num,L,R);
	}
	
	public static void merge(int num[],int L,int R){
		int mid = L+(R-L)/2;
		int temp[] = new int[R-L+1];
		/*
		 * mid把待排序数组分成两个部分
		 * p指向左半部分的最左端
		 * q指向右半部分的最左端
		 * temp每次记录p和q所指向元素的较小值
		 */
		int p = L;
		int q = mid+1;
		int k = 0;
		while(p <= mid && q <= R){
			temp[k++] = num[p] < num[q] ? num[p++]:num[q++];
		}
		//没全部遍历完的情况
		while(p <= mid)
			temp[k++] = num[p++];

		while(q <= R){
			temp[k++] = num[q++];
		}
		//回填元素
		for(int i = 0; i < temp.length;i++){
			num[L+i] = temp[i];
		}
	}
```

时间复杂度：
```
mergeSort(num,L,mid);
mergeSort(num, mid+1, R);
```
这两句的时间复杂度为T(N/2)，如果总的时间复杂度是T(N)的话

```
merge(num,L,R);
```

这句的时间复杂度为：O(N)

所以有T(N) = T(N/2)+O(N)，这种时间复杂度可以由master公式计算得出
master公式：
记录主方法的表现形式：

`T [n] = aT[n/b] + O(N^d)）`

①当d<logb^a时，时间复杂度为O(n^(logb^a))
②当d为logb^a时，时间复杂度为O((n^d)*logn)
③当d>logb^a时，时间复杂度为O(n^d)

# 快速排序
快速排序的分组原理：
比方说2，5，1，3，6，4这个序列，那么现在要以4分割这个数组，即比4小的在4的左边，比4大的在4的右边。操作如下：
可以先定义一个less指针，指向数组最左边元素的后面一个元素，即less初始值为-1。接下来的操作如下：
遍历这个数组，如果遍历的数字小于等于4，那么将该数值和less指针的前一个数据进行交换，然后less++，直至遍历完成。过程如下：
- 第一次：2比4小，less指针为-1，less的后一个数据就是2，交换自身，less++为0
- 第二次：5比4大，不管，继续向前遍历
- 第三趟：1比4小，less指针为0，less的后一个数据就是5，5和1交换，变成：2，1，5，3，6，4，less++为1
- 第四趟：第三趟：3比4小，less指针为1，less的后一个数据就是5，5和3交换，变成：2，1，3，5，6，4，less++为2
- 第五趟：5比4大，不管，继续向前遍历
- 第六趟：4等于4，less指针为2，less的后一个数据就是5，4和5交换，变成：2，1，3，4，6，5，less++为3.
- 结束。

### 扩展：荷兰国旗问题
荷兰国旗问题，和上面的问题一样在，只不过实现方法不同，比如有2，5，1，3，6，4这个序列，那么可以用两个指针，less和more，分别指向数组的头和尾巴，用来划分出比4大的区域和比4小的区域。算法的流程是这样的：
- 首先用一个指针searchIndex遍历数组，这个搜索指针的数值如果比4小，那么让less++，扩大小于区域，同时searchIndex指针向前挪动
- 如果搜索指针的数值比4大，那么让more--，扩大大于区域，但searchIndex不挪动
- 直到searchIndex+1的数值等于more的数值，即判断条件searchIndex < more

源代码：
```
public static void partition2(int[] arr){
    int less = -1;
    int more = arr.length-1;
    int searchIndex = 0;
    int anchor = arr[arr.length-1];

    while(searchIndex < more){
        if(arr[searchIndex] < anchor){
            swap(arr, searchIndex++, ++less);
        }
        else if(arr[searchIndex] > anchor){
            swap(arr, searchIndex, --more);
        }else{
            searchIndex++;
        }
    }
    swap(arr, more, arr.length-1);
}
```