# 冒泡排序
冒泡排序的基本思想是元素之间两两相隔比较，一趟过后最大的元素沉到底部，第二次后第二大元素沉到倒数第二个位置，一次类推，比如：
3,2,4,1,10,6,8
1.第一趟：
- 3和2比较，变成：2,3,4,1,10,6,8
- 3与4比较，不变
- 4与1比较，交换位置：2,3,1,4,10,6,8
- 4与10比较，不变
- 10与6比较，交换位置：2,3,1,4,6,10,8
- 10与8比较，交换位置：2,3,1,4,6,8,10
可见，一趟过后，最大元素沉底，N趟过后，排序完成
冒泡排序代码

```java
package thread;

public class LearnThread {
    public static void main(String[] args) {
        //冒泡排序
        int num[] = new int []{10,9,8,3,5,6,1};

        for(int end = num.length-1; end > 0; end--){
            for(int j = 0; j < end; j++){//j不会越界，因为是小于end
                if(num[j] < num[j+1])
                {
                    int temp = num[j];
                    num[j] = num[j+1];
                    num[j+1] = temp;
                }
            }
        }

        for(int k : num){
            System.out.println(k);
        }
    }
}
```

测试程序,可以学习下测试的方法，叫做**对数器**

```java
package thread;

import java.util.Arrays;

public class LearnThread {
	
	public static int[] bubbleSort(int[] num){
		
		if(num.length == 0)
			return null;
		if(num.length == 1)
			return num;
		
		for(int end = num.length-1; end > 0; end--){
			for(int j = 0; j < end; j++){//j不会越界，因为是小于end
				if(num[j] < num[j+1])
				{
					int temp = num[j];
					num[j] = num[j+1];
					num[j+1] = temp;
				}
			}
		}
		
		return num;
	}
	
	public static int[] generateRandomArray(int size,int value){
		/*
		 * 这一句生成一个[0,size]大小的数组，因为Math.random的范围是[0,1)，
		 * 比如size为6，size+1等于7,那么7如果乘以0.9在专成整型，就是6
		 */
		int num[] = new int[(int)((size+1)*Math.random())];
		for(int i = 0; i < num.length; i++){
			num[i] = (int)(value*Math.random()-value*Math.random());
		}
		
		return num;
	}
	
	public static int[] systemSort(int[] num){
		Arrays.sort(num);
		return num;
	}
	
	public static boolean arrayEqual(int[] num1,int[] num2){
		for(int i = 0;i < num1.length; i++){
			if(num1[i] == num2[i])
				continue;
			else
				return false;
		}
		
		return true;
	}
	
	public static void main(String[] args) {
		int nums[] = generateRandomArray(100, 100);
		int  num1[] = bubbleSort(nums);
		int num2[] = systemSort(nums);
		for(int i = 0; i < 10000; i++)
		{
			if(!arrayEqual(num1, num2)){
				System.out.println("测试错误");
			}
		}
	}
}
```

# 选择排序
选择排序就是每次在剩余的序列中选择最小的与前面的元素进行交换。

```java
public static int[] bubbleSort(int[] num){

    if(num.length == 0)
        return null;
    if(num.length == 1)
        return num;

    for(int i = 0; i < num.length; i++){
        int index = 0;
        for(int j = i+1; j < num.length; j++)
        {
            int min = num[j];
            if(num[j] < min){
                min = num[j];
                index = j;
            }
        }
        int temp = num[i];
        num[i] = num[index];
        num[index] = temp;
    }

    return num;
}
```

# 插入排序
举例：6，3，2，4
- 第一步，6不动，看3，2，4，程序默认3之前的序列都是有序的
- 第二步，3和6比较，3比6小，故3与6交换，变成：3，6，2，4，现在3，6这个部分有序
- 第三步，2与6比较，2比6小，故交换，变成3，2，6，4，2再和3比较，2比3小，故交换，编程2，3，6，4
- 第四步，4比6小，故交换，4比3大，所以停止，得出最后结果：2，3，4，6

代码：

```java
	public static int[] insertSort(int[] num){
		
		if(num.length == 0)
			return null;
		if(num.length == 1)
			return num;
		
		for(int i = 1; i < num.length; i++){
			
			for(int j = i;j > 0 && num[j] < num[j-1]; j--)
					swap(num,j,j-1);
		}
		
		return num;
	}
```

# 归并排序

递归举例：
```
	public static int getMax(int num[],int l,int r){
		if(l == r){
			return num[l];
		}
		int mid = (l+r)/2;
		int maxLeft = getMax(num,l,mid);
		int maxRight = getMax(num,mid+1,r);
		
		return Math.max(maxLeft, maxRight);
	}
```

归并排序分为两个步骤，一个是归，也就是分块。一个是并，也就是合并。
举例：比如5，3，4，6，7，2，9，3的这个序列
- 第一步，将其一分为二，分为5，3，4，6 | 7，2，9，3
- 第二步，再分，将其分为：5，3 | 4，6 | 7，2 | 9，3
- 第三步，再分，将其分成：5 | 3 | 4 | 6 | 7 | 2 | 9 | 3
- 第四步，合并：5和3两个子序列调用merge函数变成3，5，故为5，3 | 4 | 6 | 7 | 2 | 9 | 3
- 继续合并 4，6两个子序列调用merge函数变成4，6，故为5，3 | 4，6 | 7 | 2 | 9 | 3
- 继续合并：5，3和4，6两个子序列调用merge函数变成3，4，5，6故为3，4，5，6 | 7 | 2 | 9 | 3
- 如此递归，直至全部有序

图示：
![1.归并排序1](https://github.com/zihaopang/Backen-develope/blob/master/pics/%E5%B7%A6%E7%A5%9E/1.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F1.JPG)
![2.归并排序2](https://github.com/zihaopang/Backen-develope/blob/master/pics/%E5%B7%A6%E7%A5%9E/2.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.JPG)
其中的合并代码为：
![3.归并函数中的merge函数](https://github.com/zihaopang/Backen-develope/blob/master/pics/%E5%B7%A6%E7%A5%9E/3.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%AD%E7%9A%84merge%E5%87%BD%E6%95%B0.JPG)
### 代码

```java
	public static void mergeSort(int[] num,int L,int R){
		
		if(L == R)
			return;
		int mid = L + (R-L)/2;
		mergeSort(num,L,mid);
		mergeSort(num, mid+1, R);
		merge(num,L,R);
	}
	
	public static void merge(int num[],int L,int R){
		int mid = L+(R-L)/2;
		int temp[] = new int[R-L+1];
		/*
		 * mid把待排序数组分成两个部分
		 * p指向左半部分的最左端
		 * q指向右半部分的最左端
		 * temp每次记录p和q所指向元素的较小值
		 */
		int p = L;
		int q = mid+1;
		int k = 0;
		while(p <= mid && q <= R){
			temp[k++] = num[p] < num[q] ? num[p++]:num[q++];
		}
		//没全部遍历完的情况
		while(p <= mid)
			temp[k++] = num[p++];

		while(q <= R){
			temp[k++] = num[q++];
		}
		//回填元素
		for(int i = 0; i < temp.length;i++){
			num[L+i] = temp[i];
		}
	}
```

时间复杂度：
```
mergeSort(num,L,mid);
mergeSort(num, mid+1, R);
```
这两句的时间复杂度为T(N/2)，如果总的时间复杂度是T(N)的话

```
merge(num,L,R);
```

这句的时间复杂度为：O(N)

所以有T(N) = T(N/2)+O(N)，这种时间复杂度可以由master公式计算得出
master公式：
记录主方法的表现形式：

`T [n] = aT[n/b] + O(N^d)）`

①当d<logb^a时，时间复杂度为O(n^(logb^a))
②当d为logb^a时，时间复杂度为O((n^d)*logn)
③当d>logb^a时，时间复杂度为O(n^d)

# 快速排序
快速排序的分组原理：
快速排序的原理就是选取一个基准元素，将比他大的放在右边，比他小的放在左边。比方说3，5，1，2，6，4这个序列，我可以选取3作为基准。
那么我定义两个指针left和right，把基准3先行保存起来。right先向左移动（一定是right先移动），如果比基准大，则继续向左，如果比基准小，那么用该数值覆盖left指向的值（把小的数值放在左边）。然后left开始向右移动，如果比基准小，则继续向右，否则，用自身的值覆盖right指向的数值（把大的房子右边）。此过程直到left==right为止，此时，这个相等的位置就是基准该在的位置。
快速排序的核心思想就是尽量把 比基准大的数值放在其右边，比基准小的放在左边，其两处的数值覆盖就是证明。

参考帖子：`https://blog.csdn.net/nrsc272420199/article/details/82587933`

代码：

```java
static void quicksort(int n[], int left, int right) {
        int dp;
        if (left < right) {
            dp = partition(n, left, right);
            quicksort(n, left, dp - 1);
            quicksort(n, dp + 1, right);
        }
    }
 
    static int partition(int n[], int left, int right) {
        int pivot = n[left];
        while (left < right) {
            while (left < right && n[right] >= pivot)
                right--;
            
            n[left] = n[right];//小的往左放
            while (left < right && n[left] <= pivot)
                left++;
            
            n[right] = n[left];//大的往右放
        }
        n[left] = pivot;//找到正确位置
        return left;
    }
```


### 扩展：荷兰国旗问题
荷兰国旗问题，和上面的问题一样在，只不过实现方法不同，比如有2，5，1，3，6，4这个序列，那么可以用两个指针，less和more，分别指向数组的头和尾巴，用来划分出比4大的区域和比4小的区域。算法的流程是这样的：
- 首先用一个指针searchIndex遍历数组，这个搜索指针的数值如果比4小，那么让less++，扩大小于区域，同时searchIndex指针向前挪动
- 如果搜索指针的数值比4大，那么让more--，扩大大于区域，但searchIndex不挪动
- 直到searchIndex+1的数值等于more的数值，即判断条件searchIndex < more

源代码：
```
public static void partition2(int[] arr){
    int less = -1;
    int more = arr.length-1;
    int searchIndex = 0;
    int anchor = arr[arr.length-1];

    while(searchIndex < more){
        if(arr[searchIndex] < anchor){
            swap(arr, searchIndex++, ++less);
        }
        else if(arr[searchIndex] > anchor){
            swap(arr, searchIndex, --more);
        }else{
            searchIndex++;
        }
    }
    swap(arr, more, arr.length-1);
}
```