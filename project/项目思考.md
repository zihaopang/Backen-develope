# 一、数据查询
数据查询是分为最基本的dao,service,controller层。

### 1.dao层
这一层基本是属于接口类型的Mapper主键，一般使用对应的*.xml文件进行配置来实现dao层的功能。
EG:

DAO INTERFACE(用户查询部分)
```java
@Mapper
public interface UserMapper {
    User selectUserById(int id);
    User selectUserByName(String userName);
    User selectUserByEmail(String email);
    int insertUser(User user);
    int updateUserStatus(int id,int status);
    int updateUserName(int id,String userName);
    int updateUserEmail(int id,String email);
}
```

XML IMPLEMENTS：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.myiothome.dao.UserMapper">

    <sql id="selectFields">
        id,username,password,email,salt,status,activation_code,
        header_url,create_time,type
    </sql>

    <select id="selectUserById" resultType="User">
        select <include refid="selectFields"></include>
        from user
        where id=#{id}
    </select>

</mapper>
```

### 2.service层
service层主要调用dao层的一些主键，并在其中加入一些额外的数据处理。

EG:
```java
@Service
public class UserService implements MyIotHomeConstent {
    @Autowired
    UserMapper userMapper;

    ...//Mapper层的函数调用加上额外处理
}
```

### 3.Controller层
主要用于处理浏览器的提交数据以及Model数据的处理。

EG:
```java
@Controller
public class LoginController {
    @Autowired
    UserService userService;

    @RequestMapping(path = "/login")
    public String login(Model model,User user){
        Map<String,Object> map = new HashMap<>();
        map = userService.login(user);
        System.out.println(map);
        if(map == null || map.isEmpty()){
            System.out.println("hello......");
            return "/index";
        }
        else{
            model.addAttribute("errorMsg",map.get("errorMsg"));
            return "/site/login";
        }
    }

}
```

# 二、注册部分
注册部分的流程就是，用户提交数据到后台到Controller层，Controller层调用service层进行数据的处理，service层再调用dao层的mapper函数。
service层处理的结果会以一个mapper形式返回给Controller，即一个`Map<String,Object>`对象，里面装了一些处理的结果。最后Controller层
更具该结果判断是否登陆成功。

### 1.service层的事物
在service层的注册事务中，用到了user表，邮件发送，md5算法加密

myiothome.user:

```java
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) DEFAULT NULL,
  `password` varchar(50) DEFAULT NULL,
  `email` varchar(100) DEFAULT NULL,
  `salt` varchar(50) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `activation_code` varchar(100) DEFAULT NULL,
  `header_url` varchar(200) DEFAULT NULL,
  `create_time` timestamp NULL DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8
```

在注册的过程中，user依次判断用户的用户名，邮箱号是否被注册过。如果被注册过返回装载错误信息的Map给Controller，并让Controller显示错误信息。
如果用户名，邮箱号没有被使用过，那么调用MD5算法加密函数，将password和salt进行联合加密，放置到服务器中。

MD5加密函数：
```java
    public static String generateUUID(){
        return UUID.randomUUID().toString();
    }

    public static String md5(String password){
        if(password == null)
            return null;
        //产生md5字符串
        return DigestUtils.md5DigestAsHex(password.getBytes());
    }
```

再将用户名，邮箱，状态，激活码(随机生成)创建时间置入。而后向用户的邮箱发送一封激活邮件，发送激活邮件的函数为：

```java
public class MailClient {
    private static final Logger logger = LoggerFactory.getLogger(MailClient.class);

    @Autowired
    JavaMailSender javaMailSender;

    @Value("${spring.mail.username}")
    String from;

    public void sendMail(String to,String subject,String content){

        try {
            MimeMessage mimeMessage = javaMailSender.createMimeMessage();
            MimeMessageHelper mimeMessageHelper =new MimeMessageHelper(mimeMessage);
            mimeMessageHelper.setFrom(from);//发送者
            mimeMessageHelper.setTo(to);//接收者
            mimeMessageHelper.setSubject(subject);//主题
            mimeMessageHelper.setText(content,true);//可以发送html
            javaMailSender.send(mimeMessageHelper.getMimeMessage());
        }catch (MessagingException e){
            logger.error("发送邮件失败，"+e.getMessage());
        }


    }
}
```

发送的邮件内部，嵌入了激活链接,格式为：`http://localhost:8080/myiothome/activation/userId/activationCode`
只要用户点击了该链接，后台的Controll层就会捕获到该链接，该Controller会把userId对应的user中存储的激活码取出与链接中的激活码对照。
成功就将用户状态置为已激活。


