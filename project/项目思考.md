# 一、数据查询
数据查询是分为最基本的dao,service,controller层。

### 1.dao层
这一层基本是属于接口类型的Mapper主键，一般使用对应的*.xml文件进行配置来实现dao层的功能。
EG:

DAO INTERFACE(用户查询部分)
```java
@Mapper
public interface UserMapper {
    User selectUserById(int id);
    User selectUserByName(String userName);
    User selectUserByEmail(String email);
    int insertUser(User user);
    int updateUserStatus(int id,int status);
    int updateUserName(int id,String userName);
    int updateUserEmail(int id,String email);
}
```

XML IMPLEMENTS：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.myiothome.dao.UserMapper">

    <sql id="selectFields">
        id,username,password,email,salt,status,activation_code,
        header_url,create_time,type
    </sql>

    <select id="selectUserById" resultType="User">
        select <include refid="selectFields"></include>
        from user
        where id=#{id}
    </select>

</mapper>
```

### 2.service层
service层主要调用dao层的一些主键，并在其中加入一些额外的数据处理。

EG:
```java
@Service
public class UserService implements MyIotHomeConstent {
    @Autowired
    UserMapper userMapper;

    ...//Mapper层的函数调用加上额外处理
}
```

### 3.Controller层
主要用于处理浏览器的提交数据以及Model数据的处理。

EG:
```java
@Controller
public class LoginController {
    @Autowired
    UserService userService;

    @RequestMapping(path = "/login")
    public String login(Model model,User user){
        Map<String,Object> map = new HashMap<>();
        map = userService.login(user);
        System.out.println(map);
        if(map == null || map.isEmpty()){
            System.out.println("hello......");
            return "/index";
        }
        else{
            model.addAttribute("errorMsg",map.get("errorMsg"));
            return "/site/login";
        }
    }

}
```

# 二、注册部分
注册部分的流程就是，用户提交数据到后台到Controller层，Controller层调用service层进行数据的处理，service层再调用dao层的mapper函数。
service层处理的结果会以一个map形式返回给Controller，即一个`Map<String,Object>`对象，里面装了一些处理的结果。最后Controller层
更具该结果判断是否登陆成功。

### 1.service层的事物
在service层的注册事务中，用到了user表，邮件发送，md5算法加密

myiothome.user:

```java
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) DEFAULT NULL,
  `password` varchar(50) DEFAULT NULL,
  `email` varchar(100) DEFAULT NULL,
  `salt` varchar(50) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `activation_code` varchar(100) DEFAULT NULL,
  `header_url` varchar(200) DEFAULT NULL,
  `create_time` timestamp NULL DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8
```

在注册的过程中，user依次判断用户的用户名，邮箱号是否被注册过。如果被注册过返回装载错误信息的Map给Controller，并让Controller显示错误信息。
如果用户名，邮箱号没有被使用过，那么调用MD5算法加密函数，将password和salt进行联合加密，放置到服务器中。

MD5加密函数：
```java
    public static String generateUUID(){
        return UUID.randomUUID().toString();
    }

    public static String md5(String password){
        if(password == null)
            return null;
        //产生md5字符串
        return DigestUtils.md5DigestAsHex(password.getBytes());
    }
```

再将用户名，邮箱，状态，激活码(随机生成)创建时间置入。而后向用户的邮箱发送一封激活邮件，发送激活邮件的函数为：

```java
public class MailClient {
    private static final Logger logger = LoggerFactory.getLogger(MailClient.class);

    @Autowired
    JavaMailSender javaMailSender;

    @Value("${spring.mail.username}")
    String from;

    public void sendMail(String to,String subject,String content){

        try {
            MimeMessage mimeMessage = javaMailSender.createMimeMessage();
            MimeMessageHelper mimeMessageHelper =new MimeMessageHelper(mimeMessage);
            mimeMessageHelper.setFrom(from);//发送者
            mimeMessageHelper.setTo(to);//接收者
            mimeMessageHelper.setSubject(subject);//主题
            mimeMessageHelper.setText(content,true);//可以发送html
            javaMailSender.send(mimeMessageHelper.getMimeMessage());
        }catch (MessagingException e){
            logger.error("发送邮件失败，"+e.getMessage());
        }


    }
}
```

发送的邮件内部，嵌入了激活链接,格式为：`http://localhost:8080/myiothome/activation/userId/activationCode`
只要用户点击了该链接，后台的Controll层就会捕获到该链接，该Controller会把userId对应的user中存储的激活码取出与链接中的激活码对照。
成功就将用户状态置为已激活。

# 三、登陆部分

首先两个概念：
1.HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
2.Session与Cookie的区别在于Session是记录在服务端的，而Cookie是记录在客户端的。


登陆部分一共有四条信息，用户名，密码，是否记住密码选项，验证码。

具体流程为，用户在前台填写该四条（username,password,kaptch,rememenber）信息
1.首先从传回来的HttpSession对象中获取前台的验证码数据（kaptch）,在和code进行比较，如果失败，返回前台错误信息
2.调用函数判断username和password是否相匹配
3.如果匹配，判断remember，如果为true，生成一个新的Cookie对象，该cookie对象保存如下信息：
    - 用户随机生成的一个ticket
    - cookie的作用范围
    - cookie的有效时间
而后，cookie被传过来的HttpServletResponse对象返回给浏览器，浏览器将该cookie记录到本地。
在随机生成ticket的时候，需要将ticket存入数据库，为此新建表格myiothome.login_user：

```java
CREATE TABLE `login_ticket` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `ticket` varchar(45) NOT NULL,
  `status` int(11) NOT NULL,
  `expire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
```
通过ticket就可查询到用户的信息。

ticket信息需要在用户再次登陆的时候用到。用户再登陆的时候，会使用拦截器对其请求进行拦截，如果说浏览器的Cookie中
包含ticket，就通过该ticket查询到用户id，进而查询到用户。会使用ThreadLocal类来保存当前的用户，它会将用户的信息保存到当前的线程中，直到用户退出浏览器。拦截器还会在模板上增加当前的扽古用户，用来给模板判断是否显示相关信息。

后台还有一个刷新验证码的按键，它通过javascript向浏览器发送获取kaptcha的请求，后台收到的请求以后，随机生成了一个字符串，在后台的session中存放了该kaptcha的数值，并且生成了一幅验证码给response带回去，作用在验证码的图标之上。所以当login求情来的时候，后台才可以取出对应的验证码比对，因为验证码已经事先存放到session中了
