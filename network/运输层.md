# 一、概述和运输层服务
运输层协议是在不同主机上的应用进程之间提供了**逻辑通信**，运输层协议实在端系统中而不是在路由器中实现的。在发送端，运输层将从发送应用程序进程接收到报文，并将其转换成运输层分组，即**报文段**。
运输层的协议包括TCP,UDP等等
### 1.运输层和网络层的关系
网络层提供了**主机**之间的逻辑通信，而运输层为运行在不同主机上的进程提供了逻辑通信。
比如：有东西海岸两个家庭，每个家庭有个孩子收发邮件。西海岸家庭是Ann而东海岸是Bill。每星期Ann去他的所有兄弟姐妹那里收集信件，并将这些信件放到每天来的邮车上。当信件到达时，Ann也负责将信件分发到他兄弟姐妹的手上。Bill也做类似的工作。
那么，运输层的网络层可形象类比为：
- 应用层报文 = 信封上的zi
- 进程 = 堂兄弟姐妹
- 主机（端系统） = 家庭
- 运输层协议 = Ann和Bill
- 网络层协议 = 邮车

在网络中，中间路由器既不处理也不识别运输层加在应用层报文的任何信息。网络层也不能保证运输层报文的机密性，运输层可以使用加密来应对。
### 2.运输层概述
运输层的协议主要是UDP（用户数据报协议）和TCP（传输控制协议），我们将TCP和UDP的分组统称为报文段，将网络成分组称为数据报。网络层上主要是**IP**协议，它的服务模型是**尽力而为交付**，故为**不可靠服务**。
所以，总结下,TCP和UDP最基本的责任是，将两个端系统之间的IP交付服务扩展为在端系统上的两个进程之间的交付服务。将主机间的交付扩展到进程交付被称为**运输层的多路复用**和**多路分解**。UDP所能提供的服务只有数据交付和差错检查，而TCP还提供**可靠数据传输**，**拥塞控制**服务
# 二、多路复用和多路分解
**套接字**是从网络向进程传递数据和从进程向网络传递数据的门户，一个进程有一个或者多个**套接字**，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。
将运输层报文段中的数据交付到正确的套接字工作称为**多路分解**。在源主机从不同的套接字中收集数据块，并为每个数据块装上首部信息，从而生成报文段，然后将报文段传递到网络层，这叫**多路复用**。
多路复用的要求：
1. 套接字有唯一标识符（源端口号字段）
2. 每个报文段有特殊字段来指示该报文所要交付的套接字（目的端口字段）
3. 每个套接字会分配到相应的端口号，当报文到达主机时，运输层检查其目的端口号，并将其定向到相应的套接字，再由套接字进入其所连接的进程。

#### *1.无连接的多路复用和多路分解*
如代码：`clientSocket = socket(socket.AF_INET,socket.SOCK_DGRAM)`
当用上面的方式创建一个UDP套接字时，运输层会自动为该套接字分配个端口号，还可以自己绑定一个端口号，如：`clientSocket.bind(('',19157))`

举例说明UDP的复用和分解：假设在主机A中的一个进程具有UDP端口19157，他要发送一个数据块给B主机的另一个进程，该进程具有端口号46428。主机A中的运输层创建一个运输层报文段，其中包括应用程序数据和源端口号（19157）、目的端口号（46428），然后经由网络层，到达主机B，主机B的运输层检查该报文段的目的端口号（46428），并将该报文交付给46428所标识的套接字。
源端口号的作用在于，他是”返回地址“的一部分，即当B需要回发一个报文段给给A时，B到A的报文段中的目的端口号便从A到B的报文段中取值。

#### *2.面向连接的多路复用和多路分解*
TCP套接字是由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识的，TCP报文段到达主机时，该主机使用这四个值将报文段定向到相应的套接字。考虑TCP编程的例子
- TCP服务器应用程序有一个”welcming socket“,在12000端口上等待TCP的连接请求。
- TCP客户使用下面代码创建套接字并发送连接请求：
```
	clientSocket = socket(F_INET,SOCK_STREAM)
    clientSocket.connect((serverName,12000))
```
- 当服务器接入请求后，他就定位服务器进程，该进程正在端口号12000等待接收连接，该服务器进程创建一个新的套接字：`connectionSocket,addr = serverSocket.accept()`
- 新创建的连接通过四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识。不同的IP地址，即使源端口号相同，服务器也可以区分

# 三、无连接运输：UDP
UDP 相比TCP的优点：
- 关于何时、发送什么数据的应用层控制更精细
- 无需建立连接
- 无连接状态：TCP需要在端系统中维护连接状态
- 分组首部开销小：TCP首部字节：20，UDP：8

### 1.UDP报文段结构
</br>![UDP报文结构](https://github.com/zihaopang/Backen-develope/blob/master/pics/UDP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.PNG)</br>
- 长度字段指示了UDP报文段中的字节数
- 接收方使用检验和来检查该报文段中是否出现了差错

### 2.UDP检验和
检验和用于确定当UDP报文段移动时，其中的比特是否发生了改变。虽然UDP提供差错检测，但对差错回复无能为力。

# 四、可靠的数据传输原理
rdt_send()函数，可以调用数据传输协议的发送方，他将要发送的数据交付给位于接收方的较高层。当分组从信道的接收端到达时，将调用rdt_rcv()。当rdt协议想要向较高层交付数据时，将通过调用deliver_data()来完成。模型如下图所示：
</br>![可靠数据传输：服务模型和服务实现](https://github.com/zihaopang/Backen-develope/blob/master/pics/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0.PNG)</br>

### 1.构造可靠数据传输协议

#### *1.经完全可靠信道的可靠数据传输：rdt1.0*
下图显示了rdt1.0发送方和接收方的**有限状态机（FSM）**，图a的FSM定义了发送方的操作，图b的FSM定义了接收方的操作.
</br>![rdt1.0接收端](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt1.0%E6%8E%A5%E6%94%B6%E7%AB%AF.PNG)</br>
引起变迁的时间显示在表示变迁的横线上方，事件发生时所采取的动作显示在横线下方。如果时间发生后没有动作，用/\来表示.
在发送端，通过rdt_send(data)时间接收来自较高层的数据，产生一个包含该数据的分组（make_pkt(data)）并将分组发送到信道中（udt_send(packet)）.
在接收端，rdt通过rdt_rcv(packet)事件从底层接收一个分组，从分组取出数据（extract(packet,data)）并将数据传递到较高层（deliver_data(data)）。

#### *2.经具有比特差错信道的可靠数据传输：rdt2.0*
底层信道更为实际的模型是分组中的比特可能受损，研究一种报文协议，这种报文协议使用**肯定确认（OK）**和**否定确认（请重复一遍）**,得知哪些内容被接收，哪些内容因重传需要修复。基于这样的可靠数据传输协议称为**自动重传请求协议(ARQ)**，ARQ协议需要另外三种协议来处理存在比特差错的情况：
- 差错检测：需要有一种机制让接收方检测到何时出现了比特差错
- 接收方反馈：接收方回答肯定确认（ACK）和否定确认（NAK）就是这种反馈的例子
- 重传：接收方接收到有差错的分组时，发送方将重传该分组
</br>![rdt2.0发送端](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt2.0%E5%8F%91%E9%80%81%E7%AB%AF.PNG)</br>
</br>![rdt2.0接收端](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt2.0%E6%8E%A5%E6%94%B6%E7%AB%AF.PNG)</br>
rdt2.0发送端有两个状态：
在最左边的状态中，发送端协议正等待来自上层传下来的数据。当产生rdt_send(data)时，发送方将产生一个包含待发送数据的分组（sndpkt）带有检验和，然后经由udt_send(sndpkt)操作发送到该分组。
在最右边的状态中，发送方协议等待ACK或者NAK分组。如果收到一个ACK分组（rdt_rcv(rcvpkt)&&isACK(rcvpkt)）则发送方知道最近的分组已经被正确接收，因此返回等待来自上层数据的状态。如果收到一个NAK分组，该协议重传最后一个分组并等待接收方响应的ACK与NAK。注意，当发送方或者接收方处于ACK或NAK状态时，不能从上层获取更多的数据。由于这种行为，rdt2.0被称为**停等协议**
但是又出现另一个问题，如果ACK或者NAK的数据报丢失了怎么办？，rdt2.1新增了sequence number，同样使用ACK和NAK来确认信息，封包的号码用来确认是否重新传输封包。
比如接收端等待编号0的封包，结果收到封包1，此时会回传ACK1给来源端，而正在等候ACK0的来源端收到ACK1表示封包0可能遗失，所以会再重新送封包0
</br>![rdt2.1发送方](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt2.1%E5%8F%91%E9%80%81%E6%96%B9.PNG)</br>
</br>![rdt2.1接收方](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt2.1%E6%8E%A5%E6%94%B6%E6%96%B9.PNG)</br>
由于是停等协议，两个序列号就够用
因为一次要确认NAK,ACK比较麻烦，rdt2.2在ACK的信息上加上了期望的顺序号。假设发送方像接收方发送0号数据包，如果接收方接收到的是0号数据包，则返回（ACK,1），发送方接着发送一号数据包。如果接收方收到0号数据包错误，返回（ACK,0），发送方重传0号数据包
</br>![rdt2.2发送方](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt2.2%E5%8F%91%E9%80%81%E6%96%B9.PNG)</br>
</br>![rdt2.2接收方](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt2.2%E6%8E%A5%E6%94%B6%E6%96%B9.PNG)</br>
#### *3.经具有比特差错的丢包信道的可靠数据传输：rdt3.0*
rdt2.2之前的版本都重在处理数据包比特位翻转情况，rdt3.0协议还考虑到丢包的情况，除了使用ACK机制，另外在传送端多了倒数计时器。如果在RTT时间段内发送方没有收到反馈信息，那么发送方默认数据包已经丢失了，会自动重传

假设利用率：发送端实际忙于将比特送进信道的那部分时间与发送时间的比值，由于多数时间在等待ACK或则NAK，所以利用率低，所以需要改进rdt3.0.

### 2.流水线可靠数据传输协议
rdt3.0的核心问题在于他是个停等协议，流水线不使用停等方式运行，允许发送端发送多个分组而无需等待确认，但仍会带来如下影响：
- 必须增加序号范围，不可能只有0，1这两个分组，而且会存在多个在传输中尚未确认的分组
- 协议发送端和接收端必须缓存多个分组，发送方需要缓存那些发送但未被确认的分组，接收方需要缓存已经接收的分组
- 需要对差错进行恢复：两种方法：回退N步和选择重传

### 3.回退N步
主要特点是**接收方丢弃所有分组**，看一下基本原理：
对于发送方来说，每个分组都有一个序号。在每个时刻，发送方维护几个变量：
- 基序号（base）最早未确认的分组序号
- 下一个序号（nextseqnum）：最小未使用的序号，也是下一个待发送分组的序号
- 窗口长度（window size）N
根据这三个变量，将序号范围分割为四段：
- [0,base-1]：已经发送并被确认的分组
- [base,nextsquence-1]：已经发送但未被确认的分组
- [nextseuqence,base+N-1]：要立即被发送出去的分组
- 大于等于base+N：不可使用的分组
</br>![流水线协议的分组](https://github.com/zihaopang/Backen-develope/blob/master/pics/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E7%BB%84.PNG)</br>
那些已被发送但还未被确认的分组序号范围在[base，base+N-1]之间，所以，N常被称为**窗口长度**,GBN协议也常被称为**滑动窗口协议**。在实践中，一个分组首部的长度为[0,2^k-1]，k存放在固定长度的字段中。如果敞口长度过大，那么接收方将无法识别新帧和旧帧。
</br>GBN的发送方必须响应三种类型的事件：
- 上层的调用。当上层调用rdt_send()时，发送方首先检查发送窗口是否已满，即是否有N个已发送但未确认的分组。如果窗口未满，则产生一个分组将其发送，并相应的更新变量，如果窗口已满，发送方只需将数据返回给上层，暗示窗口已满，让上层等会再调用
- 收到一个ACK。在GBN中，对序号分组采取累**累积确认**的方式。如果收到序号n分组的ACK，说明接收方已经正确接收到序号n以及序号n之前的所有分组
- 超时事件。如果出现超时，发送方重传所有已发送但还未被确认的分组。
GBN的接收方动作很简单，如果一个序号为N的分组被正确接收到，并且按序，则接收方为分组n发送一个ACK，并将分组交付到上层，在所有其他情况下，接收方丢弃该分组。

### 4.选择重传（SR）
在GBN中，单个分组的差错就能引起大量分组的重传，许多分组根本没有必要重传。选择重传（SR）协议通过让发送方仅重传那些他怀疑在接收方出错的分组。
</br>
SR发送方的事件与动作：
- 从上层收到数据。当从上层收到数据后，SR发送方检查下一个可用于该分组的序号，如果在发送窗口内，则发送。否则要么将数据缓存，要么返回给上层。
- 超时。在SR中，每个分组都有定时器，因为超时发生后只能发送一个分组。一个超时事件发生后只重传一个帧。
- 收到ACK。若收到ACK，若该分组在窗口内，则将分组标记为已接收。如果该分组的序号等于send_base（最左边的序号）,那么将send_base移动到具有最小序号的未确认分组。如果窗口移动了并且窗口内有未发送分组，则发送这些分组。

</br>
SR接收方：
SR接收方将确认一个正确接收的帧不管其是否按序。失序的帧将被缓存，并返回给发送方一个确认帧，直到所有帧被接收，这时将第一批帧按序交付给上层

# 五、面向连接的运输：TCP
### 1.TCP连接
TCP被称为是面向连接的，这种连接不像TDM或者FDM电路，事实上，中间路由器对TCP连接完全视而不见，他们看到的是数据报，而不是连接。TCP提供**全双工服务**，其连接也总是点对点的，所谓“多播”在TCP中不存在。
再看一下TCP 连接是怎么建立的，在之前的章节中，客户端通过如下命令实现此目的：`clientSocket.connect((serverName,serverPort))`，其中，serverName是服务器的名字，serverPort标识了服务器的进程。客户端TCP便开始和服务器上的TCP建立了一条TCP连接。**三次握手**在后面介绍
一旦建立TCP连接，就可以互相发送数据，TCP将这些数据引导到**发送缓存**里，TCP可以从缓存中去除并放入数据的数量受限于**最大报文段长度（MAximun Segment Size,MSS）**,MSS通常根据最初确定的由本地主机发送的最大链路层帧长度来设置，注意是应用层数据的最大长度，不包括TCP首部。所以TCP连接的组成包括：一台主机上的缓存、变量和套接字以及另一台主机上的缓存，变量和套接字，如下图所示：
</br>![TCP发送缓存和接受缓存](https://github.com/zihaopang/Backen-develope/blob/master/pics/TCP%E5%8F%91%E9%80%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%8E%A5%E5%8F%97%E7%BC%93%E5%AD%98.PNG)</br>

### 2.TCP报文段结构
</br>![TCP报文段结构](https://github.com/zihaopang/Backen-develope/blob/master/pics/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84.PNG)</br>
- 源端口号和目的端口号：用于多路复用/分解
- 检验和：检验数据，同UDP相同
- 序号字段（32比特）和确认号字段：用于实现可靠传输
- 16比特的接收窗口字段：用于流量控制
- 4比特的首部长度字段：指示了TCP首部的长度
- 可选与变长的选项字段：：用于接收方和发送方协商最大报文长度（MSS）时，或者在告诉网络环境下用于窗口调节因子时候使用。
- 6比特的标志字段：ACK比特用于指示数据报有效，RST,SYN,FIN比特用于连接的建立和拆除。URG比特用来指示报文段里存在着“紧急”数据，紧急数据的最后一个字节由16比特的**紧急数据指针字段**指出

#### 序号和确认号
序号：比如主角及A上的TCP将隐式地对数据流中的每一个字节编号，假定数据流由一个包含500000字节的文件组成，其MSS为1000字节，数据流首字节的编号是0，第二个报文段编号是1000，第三个是2000，以此类推...
</br>
确认号：是主机A期望从主机B收到来自主机B下一个字节的编号。假设主机A已经收到了来自主机B的编号为0~535的所有字节，同时他准备发送一个报文段给主机B。此时主机等待主机B发送536及其之后的所有字节，所以该报文段的确认号是536.

### 3.往返时间的预估和超时
#### *1.估计往返时间*
报文段样本的RTT就是从某报文段到该报文段的确认被收到之间的时间量。大多数TCP的实现仅仅在某个时刻做一次SampleRTT测量。由于链路的变化，sampleRTT的值会随之波动，任何给定的SampleRTT的值都是非典型的.TCP维持一个SampleRTT的平均值（称为EstimatedRTT），一旦获得新的SampleRTT，则`EstimatedRTT = (1-α)·Estimated+α·SampleRTT`，α的数值一般取0.125.
除了估算RTT以外，测量RTT的变化也是有价值的，DevRTT用于估算SampleRTT偏离EstimatesRTT的程度`DevRTT = (1-β)·DevRTT + β·|SampleRTT-EstiamtesRTT|`，如果sampleRTT的值波动较小，那么DevRTT的值就会很小，如果波动很大，那么DevRTT的数值就会很大，β的数值一般为0.25。
#### *2.设置和管理重传超时间隔*
超时时间间隔应该大于等于EstimatedRTT，但又不能大太多，因此要求将超时间隔设置为EstimatedRTT加上一定的余量。当SampleRTT波动较大时，余量大一些，波动较小时，余量小一些：`TimeoutInterval = EstmatedRTT + 4·DevRTT`

### 4.可靠数据传输
TCP在IP不可靠的尽力而为服务之上建立了一种**可靠数据传输服务**。在TCP发送方有三个与发送和重传有关的主要事件：
- TCP从应用程序接收数据，并将数据放在报文段中，在交给IP，每一个报文段都有一个序号。同时，启动定时器，该定时器的过期间隔是TimeoutInterval
- 超时：TCP通过重传引起超时报文段相应超时事件，然后TCP重启定时器。
- 接收ACK：当此事件发生时，TCP将ACK的数值(y)与它的变量SendBase进行比较，如果y>sendBase则该ACK是在确认一个或者多个未被确认的报文段，说明[sendbase,y-1]的数据都接收到。同时更新sendbase变量

#### *1.一些有趣的情况*
- 第一种情况：A像B发送一个报文段，假设该报文段的序号是92，包含8字节数据，虽然A发出的报文段在B上被收到，但B发往A的报文丢失了。超时事件发生后，A会重新传递报文，但B收到了重复的数据，所以将数据丢弃了
- 第二种情况：主机A连续发送两个报文段，第一个报文序列是92，包含8字节，第二个报文段序号是100，包含20个字节，假设B主机收到了报文，发送了两个确认，分别是100和120。但如果120提前到达，则第二个序列不会重传
- 第三种情况：和第二种情况一样，不过如果主机B收到了第二个报文，同时回复120给主机A，那么主机A就知道B已经收到了119及以前的所有字节，所以主机A不会重传连个报文中的任何一个

#### *2.超时时间加倍*
TCP重传具有最小序号的还未被确认的报文段，并且每次TCP 重传时都会将下一次超时时间间隔加倍。

#### *3.快速重传*
当一个报文段丢失时，会等待一定的超时周期然后才重传分组，增加了端到端的时延。
当接收端收到比期望序列号大的报文段时，便会重复发送最近一次确认的报文段。如果收到同一个数据包的三次冗余ACK，那么进行该数据包的重传

### 4.流量控制
如果某应用程序读取数据时相对缓慢，而发送方发送的太多，太快，发送的数据就会很容易使得该连接的接收缓存溢出
TCP为其应用程序提供了**流量控制服务**，流量控制服务是一种速度匹配服务，发送方的速率应该与接收方相匹配。而TCP的发送方可能因为速率太快而被遏制，这种行为被称为**拥塞控制**。
TCP通过让发送方维护一个称为**接收窗口**的变量来提供流量控制服务，即接收窗口用于给发送方一个指示，说明该接收方还有多少可用的缓存空间。假设主机A像主机B发送一个大文件，并用RcvBuffer来表示其大小，定义如下变量：
- LastByteRead:主机B上的应用进程从缓存读出数据流的最后一个字节的编号
- LastByteRcvd:从网络中到达并且已经放入主机B缓存中的数据流的最后一个字节编号
那么TCP如果不允许溢出的话：`LastByteRcvd - LastByteRead <= RcvBuffer`
接收窗口用rwnd表示，根据缓存可用空间的数量来设置：
</br>`rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]`</br>
主机B通过把当前的rwnd值放入发给主机A的报文中，通知主机A它还有多少缓存空间。

### 5.TCP的连接管理
用户进程首先通知客户TCP，它想建立一个到主机上的连接。客户TCP会用以下方式进行连接：
- 第一步：客户端TCP像服务器端的TCP发送一个特殊的TCP报文段。该报文段中SYN标志位被置为1，同时，客户会随机选择一个初始序号（client_isn）并将该序号放置在TCP_SYN的字段中
- 第二步：服务器接收到该报文，返回一个报文段。该报文段首部包含三个重要信息。首先，SYN被置为1，其次,TCP首部的确认字段被改为client+1,最后，服务器选择自己的初始序列号（server_isn），并将其放置到TCP报文段首部的序号字段中。该报文被称为**SYNACK报文段**
- 第三步：在收到SYNACK报文段之后，客户主机像服务器发送另外一个报文段，该报文段对服务器的允许连接的报文段进行了确认（TCP首部确认字段为server+1来确认）
具体过程如下图所示：
</br>![TCP三次握手：报文段交换](https://github.com/zihaopang/Backen-develope/blob/master/pics/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9A%E6%8A%A5%E6%96%87%E6%AE%B5%E4%BA%A4%E6%8D%A2.PNG)</br>

TCP连接的关闭：
- 客户应用进程发出一个关闭连接命令，引起TCP向服务器发送一个特殊的报文段，这个报文段首部中一个标志位**FIN**被置为1.
- 服务器收到该报文段之后，就像发送方返回一个确认报文段
- 接着，服务器发送自己的终止报文段，其FIN被置为1
- 最后，该客户对这个服务器的终止报文段进行确认

</br>![关闭一条TCP连接](https://github.com/zihaopang/Backen-develope/blob/master/pics/%E5%85%B3%E9%97%AD%E4%B8%80%E6%9D%A1TCP%E8%BF%9E%E6%8E%A5.PNG)</br>

当主机端口不接受请求报文所请求的端口，那么TCP报文将RST标志位置为1。

# 六、拥塞控制原理
### 1.拥塞的原因与代价
#### *1.情况一：两个发送方具有一台无穷大的缓存路由器*
那么可知，链路发送或者接收的最大速率是R/2,但当速率接近R/2时候，链路会变得更加拥塞。如下图所示：
</br>![拥塞情况1](https://github.com/zihaopang/Backen-develope/blob/master/pics/%E6%8B%A5%E5%A1%9E%E6%83%85%E5%86%B51.PNG)</br>
#### *2.情况二：两个发送方和一台具有有限缓存的路由器*
一种理想的情况是，发送方先检测路由器是否满了，没满就发送数据，这种和情况一是一样的。
还有一种更实际的情况，发送方得知丢包了，然后重传数据，这种情况的最大吞吐量是R/3
最后一种是，发送方发送对的超时分组和后来重传分组同时被接收方收到，这样会丢弃一个多余的分组，这种的利用率为R/4
### 2.拥塞控制的方法
- 端到端的拥塞控制：网络层没有为运输层提供拥塞控制支持，即使存在拥塞，端系统也必须通过网络观察来推断。TCP报文段的丢失被认为是网络拥塞的一个迹象，TCP会相应的减小其窗口的长度
- 网络辅助的拥塞控制：网络构件（即路由器）向发送方提供关于网络拥塞情况的发聩信息
### 3.网络辅助拥塞控制的例子：ATM ABR拥塞控制
对于ATM ABR服务，数据从源经过一系列中间交换机传输到目的地。在数据信元中夹杂着**资源管理单元(RM)**.当一个RM信元到达目的地时，它被调转方向并向发送方发送，从而反馈网络拥塞情况
ABR提供三种机制用于从交换机向接收方。略

# 七、TCP拥塞控制
### 1.拥塞
拥塞控制：防止过多的数据注入到网络中，这样可以使得网络中的路由器或则链路不过载，从而产生丢包等问题。
拥塞控制的代价：需要获得网络流量的信息，需要在报文段中增加一些信令，这样就会产生额外的开销
#### *几种拥塞控制方法*
慢开始（slow-start）,拥塞避免（congestion avoidance）,快重传（fast retransmit）和快恢复（fast recovery）
### 2.慢开始算法
具体思想：当主机开始发送数据时候，如果立即将大量的字节注入网络，那么很有可能引起网络拥塞。因此，较好的方法是由小到大的组件增大发送窗口。慢开始算法通常在刚刚开始发送报文段时，先把拥塞窗口cwnd的数值设置为最大报文段MSS的数值。而在接收到一个新的确认信息之后，把拥塞窗口增加一个MSS。
慢开始的算法的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时候子先设置cwnd=1.
但为了防止cwnd增长过大引起的网络拥塞，还需要设置一个ssthresh状态变量。慢开始门限ssthresh的用法如下：
- 当cwnd < ssthresh时候，使用上诉的慢开始算法
- 当cwnd > ssthresh时候，停止使用慢开始算法，转而使用拥塞避免算法
- 当cwnd = ssthesh时候，既可以使用慢开始算法，也可以使用拥塞避免算法
### 3.拥塞避免算法
让拥塞窗口缓慢的变大，即每经过一个往返时间的RT就把发送方的拥塞窗口cwnd+1,而不是加倍。
值得注意的是，无论是慢开始阶段还是拥塞避免阶段，只要判断网络出现了拥塞，就要把慢开始门限设置为出现拥塞时候发送方窗口值的一半，然后把cwnd重新置为1，执行慢开始算法。
#### *举例说明*
</br>![慢开始和避免拥塞算法举例](https://github.com/zihaopang/Backen-develope/blob/master/pics/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E9%81%BF%E5%85%8D%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95%E4%B8%BE%E4%BE%8B.PNG)</br>
1. 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16。
2. 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd 随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线 性规律增长。
3. 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值 24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过 一个往返时间增加一个MSS的大小。
### 4.快重传和快恢复
快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时候才捎带确认。
#### *1.举例说明*
接收方收到了M1,M2后都发出了确认。现在假定接收方没有收到M3但收到了M4，根据可靠传输原理，可以什么都不做，也可以在是当时候发送对M2的确认。但快速重传规定接收方应该及时发送对M2的重复确认。接着，接收方收到了M5和M6，也还要继续对M2发送重复确认。这样，发送方一共收到了四个对M2的确认，后三个均为重复确认。快速重传规定，只要收到三个重复确认，就要立即重传该报文段。
#### *2.快恢复*
- 当发生快重传的时候，就说明网络发生了拥塞，为了避免网络发生拥塞，把慢开始门限ssthresh减半
- 但接下来并不执行慢开始算法，而是把cwnd的数值设置为慢开始门限ssthresh减半后的数值，仔执行拥塞避免算法。如下图所示

</br>![收到三个重复确认转入快恢复](https://github.com/zihaopang/Backen-develope/blob/master/pics/%E6%94%B6%E5%88%B0%E4%B8%89%E4%B8%AA%E9%87%8D%E5%A4%8D%E7%A1%AE%E8%AE%A4%E8%BD%AC%E5%85%A5%E5%BF%AB%E6%81%A2%E5%A4%8D.PNG)</br>