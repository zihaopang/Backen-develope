</br>![可靠数据传输：服务模型和服务实现](https://github.com/zihaopang/Backen-develope/blob/master/pics/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0.PNG)</br>

### 1.构造可靠数据传输协议

#### *1.经完全可靠信道的可靠数据传输：rdt1.0*
下图显示了rdt1.0发送方和接收方的**有限状态机（FSM）**，图a的FSM定义了发送方的操作，图b的FSM定义了接收方的操作.
</br>![](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt1.0%E6%8E%A5%E6%94%B6%E7%AB%AF.PNG)</br>
引起变迁的时间显示在表示变迁的横线上方，事件发生时所采取的动作显示在横线下方。如果时间发生后没有动作，用/\来表示.
在发送端，通过rdt_send(data)时间接收来自较高层的数据，产生一个包含该数据的分组（make_pkt(data)）并将分组发送到信道中（udt_send(packet)）.
在接收端，rdt通过rdt_rcv(packet)事件从底层接收一个分组，从分组取出数据（extract(packet,data)）并将数据传递到较高层（deliver_data(data)）。

#### *2.经具有比特差错信道的可靠数据传输：rdt2.0*
底层信道更为实际的模型是分组中的比特可能受损，研究一种报文协议，这种报文协议使用**肯定确认（OK）**和**否定确认（请重复一遍）**,得知哪些内容被接收，哪些内容因重传需要修复。基于这样的可靠数据传输协议称为**自动重传请求协议(ARQ)**，ARQ协议需要另外三种协议来处理存在比特差错的情况：
- 差错检测：需要有一种机制让接收方检测到何时出现了比特差错
- 接收方反馈：接收方回答肯定确认（ACK）和否定确认（NAK）就是这种反馈的例子
- 重传：接收方接收到有差错的分组时，发送方将重传该分组
</br>![rdt2.0发送端](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt2.0%E5%8F%91%E9%80%81%E7%AB%AF.PNG)</br>
</br>![rdt2.0接收端](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt2.0%E6%8E%A5%E6%94%B6%E7%AB%AF.PNG)</br>
rdt2.0发送端有两个状态：
在最左边的状态中，发送端协议正等待来自上层传下来的数据。当产生rdt_send(data)时，发送方将产生一个包含待发送数据的分组（sndpkt）带有检验和，然后经由udt_send(sndpkt)操作发送到该分组。
在最右边的状态中，发送方协议等待ACK或者NAK分组。如果收到一个ACK分组（rdt_rcv(rcvpkt)&&isACK(rcvpkt)）则发送方知道最近的分组已经被正确接收，因此返回等待来自上层数据的状态。如果收到一个NAK分组，该协议重传最后一个分组并等待接收方响应的ACK与NAK。注意，当发送方或者接收方处于ACK或NAK状态时，不能从上层获取更多的数据。由于这种行为，rdt2.0被称为**停等协议**
但是又出现另一个问题，如果ACK或者NAK的数据报丢失了怎么办？，rdt2.1新增了sequence number，同样使用ACK和NAK来确认信息，封包的号码用来确认是否重新传输封包。
比如接收端等待编号0的封包，结果收到封包1，此时会回传ACK1给来源端，而正在等候ACK0的来源端收到ACK1表示封包0可能遗失，所以会再重新送封包0
</br>![rdt2.1发送方](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt2.1%E5%8F%91%E9%80%81%E6%96%B9.PNG)</br>
</br>![rdt2.1接收方](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt2.1%E6%8E%A5%E6%94%B6%E6%96%B9.PNG)</br>
由于是停等协议，两个序列号就够用
因为一次要确认NAK,ACK比较麻烦，rdt2.2在ACK的信息上加上了期望的顺序号。假设发送方像接收方发送0号数据包，如果接收方接收到的是0号数据包，则返回（ACK,1），发送方接着发送一号数据包。如果接收方收到0号数据包错误，返回（ACK,0），发送方重传0号数据包
</br>![rdt2.2发送方](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt2.2%E5%8F%91%E9%80%81%E6%96%B9.PNG)</br>
</br>![rdt2.2接收方](https://github.com/zihaopang/Backen-develope/blob/master/pics/rdt2.2%E6%8E%A5%E6%94%B6%E6%96%B9.PNG)</br>
#### *3.经具有比特差错的丢包信道的可靠数据传输：rdt3.0*
rdt2.2之前的版本都重在处理数据包比特位翻转情况，rdt3.0协议还考虑到丢包的情况，除了使用ACK机制，另外在传送端多了倒数计时器。如果在RTT时间段内发送方没有收到反馈信息，那么发送方默认数据包已经丢失了，会自动重传

假设利用率：发送端实际忙于将比特送进信道的那部分时间与发送时间的比值，由于多数时间在等待ACK或则NAK，所以利用率低，所以需要改进rdt3.0.

### 2.流水线可靠数据传输协议
rdt3.0的核心问题在于他是个停等协议，流水线不使用停等方式运行，允许发送端发送多个分组而无需等待确认，但仍会带来如下影响：
- 必须增加序号范围，不可能只有0，1这两个分组，而且会存在多个在传输中尚未确认的分组
- 协议发送端和接收端必须缓存多个分组，发送方需要缓存那些发送但未被确认的分组，接收方需要缓存已经接收的分组
- 需要对差错进行恢复：两种方法：回退N步和选择重传

### 3.回退N步
主要特点是**接收方丢弃所有分组**，看一下基本原理：
对于发送方来说，每个分组都有一个序号。在每个时刻，发送方维护几个变量：
- 基序号（base）最早未确认的分组序号
- 下一个序号（nextseqnum）：最小未使用的序号，也是下一个待发送分组的序号
- 窗口长度（window size）N
根据这三个变量，将序号范围分割为四段：
- [0,base-1]：已经发送并被确认的分组
- [base,nextsquence-1]：已经发送但未被确认的分组
- [nextseuqence,base+N-1]：要立即被发送出去的分组
- 大于等于base+N：不可使用的分组
</br>![流水线协议的分组](https://github.com/zihaopang/Backen-develope/blob/master/pics/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E7%BB%84.PNG)</br>
那些已被发送但还未被确认的分组序号范围在[base，base+N-1]之间，所以，N常被称为**窗口长度**,GBN协议也常被称为**滑动窗口协议**。在实践中，一个分组首部的长度为[0,2^k-1]，k存放在固定长度的字段中。如果敞口长度过大，那么接收方将无法识别新帧和旧帧。